### Применённые паттерны проектирования:
- Стратегия (можно в рантайме менять IComputeStrategy в ExpressionModel при дальнейшем расширении приложения)
- Внедрение зависимостей с использованием DI-контейнера Zenject
- Соблюдены принципы единой ответственности и инверсии зависимостей (применены интерфейсы, позволяющие избегать ссылок на конкретные реализации), остальным принципам solid приложение следует в силу маленького объёма кода - не получится накидать лишних методов в интерфейсы или не следовать принципу подстановки, т.к. нет наследуемых классов

### Проблемы при выполнении тестового задания
- Биндинг в Zenject, дольше всего мучался с тем, что контейнер не создавал префаб Canvas на сцене, пока не построен граф объектов, а я пытался резолвить канвас в других объектах для вызова UnderTransform. Решением стало объявить поле в другом инсталлере и инжектить зависимость в него (bad practice, но другого решения я не нашёл).

### Что можно улучшить
- Применить фабричный метод для создания Compute-стратегий
- Выводить результат и ошибку разными вьюхами
- Сделать нормальные сейвы - в текущей реализации точно будут проблемы с несериализованными типами, и я вообще не уверен, что даже конвертация в строку и обратно будет работать
- Сделать менеджер окон
